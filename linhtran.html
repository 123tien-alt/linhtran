<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>yeulinhvcl</title>
  <style>
    body { margin:0; background:#000; overflow:hidden; font-family: Arial, sans-serif; }
    canvas { display:block; width:100vw !important; height:100vh !important; position:absolute; top:0; left:0; z-index:1;}
    .stars-bg { position:fixed; top:0; left:0; width:100%; height:100%; background:radial-gradient(circle, rgba(255,255,255,0.8) 1px, transparent 1px); background-size:10px 10px; z-index:0; animation:twinkle 4s infinite linear; }
    @keyframes twinkle { 0%{opacity:0.5} 50%{opacity:0.9} 100%{opacity:0.5} }
    .info { position:absolute; top:10px; left:10px; color:#fff; background:rgba(0,0,0,0.6); padding:8px; border-radius:6px; z-index:3; font-size:14px;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
</head>
<body>
  <div class="stars-bg"></div>
  <div class="info"></div>

  <svg id="heartSVG" viewBox="0 0 600 552" style="position:absolute; width:0; height:0; overflow:visible; pointer-events:none;">
    <path id="heartPath" d="M300,107.77C284.68,55.67,239.76,0,162.31,0,64.83,0,0,82.08,0,171.71c0,.48,0,.95,0,1.43-.52,19.5,0,217.94,299.87,379.69v0l0,0,.05,0,0,0,0,0v0C600,391.08,600.48,192.64,600,173.14c0-.48,0-.95,0-1.43C600,82.08,535.17,0,437.69,0,360.24,0,315.32,55.67,300,107.77" fill="#ee5282"/>
  </svg>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
      "three/addons/controls/OrbitControls.js": "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js",
      "three/addons/loaders/FontLoader.js": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/FontLoader.js",
      "three/addons/geometries/TextGeometry.js": "https://unpkg.com/three@0.152.2/examples/jsm/geometries/TextGeometry.js"
    }
  }
  </script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { FontLoader } from 'three/addons/loaders/FontLoader.js';
  import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 5000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
  renderer.setClearColor(0x000000);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  document.body.appendChild(renderer.domElement);

  const audioListener = new THREE.AudioListener();
  camera.add(audioListener);
  const sound = new THREE.Audio(audioListener);
  const audioLoader = new THREE.AudioLoader();
  let isPlaying = false;
  let isAudioLoaded = false;
  audioLoader.load(
    'nangmangemve.mp3',
    buffer => { sound.setBuffer(buffer); sound.setLoop(true); sound.setVolume(0.5); isAudioLoaded = true; console.log('Audio loaded successfully'); },
    undefined,
    err => { console.warn('Audio load failed', err); }
  );

  function toggleAudio() {
    if (audioListener.context.state === 'suspended') {
      audioListener.context.resume().then(playAudio).catch(e=>console.warn(e));
    } else playAudio();
  }
  function playAudio(){
    if (!isAudioLoaded) { console.warn('audio not ready'); return; }
    try { if(isPlaying){ sound.pause(); isPlaying=false; } else { sound.play(); isPlaying=true; } }
    catch(e){ console.warn('Audio playback:', e); }
  }
  sound.onEnded = ()=> { isPlaying=false; };

  window.addEventListener('keydown', e => { if(e.code==='Space'){ e.preventDefault(); toggleAudio(); triggerCameraAnimation(); } });
  window.addEventListener('dblclick', e => { e.preventDefault(); toggleAudio(); triggerCameraAnimation(); });

  let lastTapTime = 0, lastTapPos = {x:0,y:0};
  window.addEventListener('touchstart', (event) => {
    if(event.touches.length!==1) return;
    const currentTime = Date.now();
    const pos = { x: event.touches[0].clientX, y: event.touches[0].clientY };
    const dt = currentTime - lastTapTime;
    const dist = Math.hypot(pos.x-lastTapPos.x, pos.y-lastTapPos.y);
    if (dt <= 300 && dist < 30) { toggleAudio(); triggerCameraAnimation(); }
    lastTapTime = currentTime; lastTapPos = pos;
  });

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.05;
  controls.minDistance = 50; controls.maxDistance = 1700;
  controls.target.set(0, -1200, 0);
  camera.position.set(0, -500, 0);
  controls.update();

  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const light1 = new THREE.PointLight(0xffffff, 1, 500); light1.position.set(100,100,100); scene.add(light1);
  const light2 = new THREE.PointLight(0xffffff, 0.5, 500); light2.position.set(-100,-100,-100); scene.add(light2);

  const particleCount = 1500;
  const particlesGeometry = new THREE.BufferGeometry();
  const posArray = new Float32Array(particleCount * 3);
  const colorsArray = new Float32Array(particleCount * 3);
  for (let i = 0; i < particleCount; i++) {
    const ix = i*3;
    posArray[ix]   = (Math.random() - 0.5) * 3000;
    posArray[ix+1] = (Math.random() - 0.5) * 3000;
    posArray[ix+2] = (Math.random() - 0.5) * 3000;
    const c = new THREE.Color(Math.random()*0.5+0.5, Math.random()*0.3+0.7, Math.random()*0.5+0.5);
    colorsArray[ix] = c.r; colorsArray[ix+1] = c.g; colorsArray[ix+2] = c.b;
  }
  particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
  const particleMaterial = new THREE.PointsMaterial({ size:7, vertexColors:true, transparent:true, opacity:0.8 });
  const particles = new THREE.Points(particlesGeometry, particleMaterial); particles.position.y += 50;
  scene.add(particles);

  const diskParticleCount = 35000;
  const maxRadius = 500;
  const diskGeometry = new THREE.BufferGeometry();
  const diskPos = new Float32Array(diskParticleCount * 3);
  const diskCol = new Float32Array(diskParticleCount * 3);
  for (let i=0;i<diskParticleCount;i++){
    const ix = i*3;
    const radius = Math.sqrt(Math.random()) * maxRadius;
    const angle = Math.random()*Math.PI*2;
    const height = (Math.random()-0.5)*3*2;
    diskPos[ix] = Math.cos(angle)*radius;
    diskPos[ix+1] = height;
    diskPos[ix+2] = Math.sin(angle)*radius;
    diskCol[ix] = 1.0; diskCol[ix+1] = 0.8; diskCol[ix+2] = 0.9;
  }
  diskGeometry.setAttribute('position', new THREE.BufferAttribute(diskPos, 3));
  diskGeometry.setAttribute('color', new THREE.BufferAttribute(diskCol, 3));
  const diskMaterial = new THREE.PointsMaterial({ size:0.7, vertexColors:true, transparent:true, opacity:1 });
  const particleDisk = new THREE.Points(diskGeometry, diskMaterial); scene.add(particleDisk);

  const innerDiskParticleCount = 2900;
  const innerDiskGeometry = new THREE.BufferGeometry();
  const innerPos = new Float32Array(innerDiskParticleCount * 3);
  const innerCol = new Float32Array(innerDiskParticleCount * 3);
  for (let i=0;i<innerDiskParticleCount;i++){
    const ix=i*3;
    const radius = Math.sqrt(Math.random())*90;
    const angle = Math.random()*Math.PI*2;
    const height = (Math.random()-0.5)*5*2;
    innerPos[ix]=Math.cos(angle)*radius;
    innerPos[ix+1]=height;
    innerPos[ix+2]=Math.sin(angle)*radius;
    innerCol[ix]=1.0; innerCol[ix+1]=0.8; innerCol[ix+2]=0.9;
  }
  innerDiskGeometry.setAttribute('position', new THREE.BufferAttribute(innerPos,3));
  innerDiskGeometry.setAttribute('color', new THREE.BufferAttribute(innerCol,3));
  const innerParticleDisk = new THREE.Points(innerDiskGeometry, diskMaterial); scene.add(innerParticleDisk);

  const outermostDiskParticleCount = 2000;
  const outermostDiskGeometry = new THREE.BufferGeometry();
  const outPos = new Float32Array(outermostDiskParticleCount * 3);
  const outCol = new Float32Array(outermostDiskParticleCount * 3);
  for (let i=0;i<outermostDiskParticleCount;i++){
    const ix=i*3;
    const radius = 500 + Math.random() * 50;
    const angle = Math.random()*Math.PI*2;
    const height = (Math.random()-0.5)*2*2;
    outPos[ix]=Math.cos(angle)*radius;
    outPos[ix+1]=height;
    outPos[ix+2]=Math.sin(angle)*radius;
    outCol[ix]=1.0; outCol[ix+1]=0.8; outCol[ix+2]=0.9;
  }
  outermostDiskGeometry.setAttribute('position', new THREE.BufferAttribute(outPos,3));
  outermostDiskGeometry.setAttribute('color', new THREE.BufferAttribute(outCol,3));
  const outermostParticleDisk = new THREE.Points(outermostDiskGeometry, diskMaterial); scene.add(outermostParticleDisk);

  const sphereGeometry = new THREE.SphereGeometry(30, 64, 64);
  const sphereMaterial = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0.0 } },
    vertexShader: `
      varying vec2 vUv; varying vec3 vNormal;
      void main(){ vUv=uv; vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
    `,
    fragmentShader: `
      uniform float uTime; varying vec2 vUv; varying vec3 vNormal;
      float random(vec2 st){ return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123); }
      float noise(vec2 st){
        vec2 i=floor(st); vec2 f=fract(st);
        float a=random(i), b=random(i+vec2(1.0,0.0)), c=random(i+vec2(0.0,1.0)), d=random(i+vec2(1.0,1.0));
        vec2 u = f*f*(3.0-2.0*f);
        return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
      }
      void main(){
        vec2 uv = vUv;
        float n = noise(uv*3.0 + uTime*0.1);
        vec3 color = vec3(sin(n*6.28 + uTime*0.2)*0.5+0.7, sin(n*6.28+uTime*0.2+2.0)*0.5+0.7, sin(n*6.28+uTime*0.2+4.0)*0.5+0.7);
        float twinkle = sin(uTime*2.0 + n*10.0)*0.3 + 0.8;
        color *= twinkle;
        float intensity = dot(vNormal, vec3(0.0,0.0,1.0));
        color *= mix(0.8,1.2,intensity);
        gl_FragColor = vec4(color,1.0);
      }
    `,
    side: THREE.DoubleSide
  });
  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); scene.add(sphere);

  const atmosphereGeometry = new THREE.SphereGeometry(31.2, 64, 64);
  const atmosphereMaterial = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0.0 } },
    vertexShader: `varying vec3 vNormal; void main(){ vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
    fragmentShader: `varying vec3 vNormal; void main(){ float intensity = pow(0.7 - dot(vNormal, vec3(0.0,0.0,1.0)), 2.0); gl_FragColor = vec4(0.3,0.6,1.0, intensity*0.6); }`,
    side: THREE.BackSide, transparent:true, blending:THREE.AdditiveBlending
  });
  const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial); scene.add(atmosphere);

  const fontLoaderText = new FontLoader();
  fontLoaderText.load('https://unpkg.com/three@0.152.2/examples/fonts/helvetiker_regular.typeface.json', font => {
    const textGeo = new TextGeometry('HAPPY 20/10 <3', { font, size:30, height:0.5, curveSegments:12 });
    const textMat = new THREE.MeshPhongMaterial({ color:0xff69b4, emissive:0xff99cc, shininess:80 });
    const textMesh = new THREE.Mesh(textGeo, textMat);
    textMesh.position.set(-170,130,0);
    scene.add(textMesh);
  });

  const flowerRing = new THREE.Group();
  scene.add(flowerRing);
  const textureLoader = new THREE.TextureLoader();

  const imageList = [
    'flower1.jpg', 'flower2.jpg', 'flower3.jpg', 'flower4.jpg', 'flower5.jpg',
    'flower6.jpg', 'flower7.jpg', 'flower8.jpg', 'flower9.jpg', 'flower10.jpg',
    'flower11.jpg', 'flower12.jpg', 'flower13.jpg', 'flower14.jpg', 'flower15.jpg',
    'flower16.jpg', 'flower17.jpg', 'flower18.jpg', 'flower19.jpg', 'flower20.jpg',
    'flower21.jpg', 'flower22.jpg', 'flower23.jpg', 'flower24.jpg', 'flower25.jpg',
    'flower26.jpg', 'flower27.jpg', 'flower28.jpg', 'flower29.jpg', 'flower30.jpg',
    'flower31.jpg'
  ];

  const numFlowers = 1600;
  const innerRadius = 120, outerRadius = 500, heightRange = 10;

  const textures = imageList.map(img => textureLoader.load(img));

  let imageIndices = [];
  for (let i = 0; i < numFlowers; i++) {
    imageIndices.push(i % textures.length);
  }
  for (let i = imageIndices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [imageIndices[i], imageIndices[j]] = [imageIndices[j], imageIndices[i]];
  }

  const placeholderMat = new THREE.SpriteMaterial({ color: 0xffffff, opacity: 0.1, transparent: true });
  const sprites = [];
  for (let i = 0; i < numFlowers; i++) {
    const idx = imageIndices[i];
    const sprite = new THREE.Sprite(placeholderMat.clone());
    sprite.userData = { imgIdx: idx };
    const angle = Math.random() * Math.PI * 2;
    const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
    const height = (Math.random() - 0.5) * heightRange * 2;
    sprite.position.set(Math.cos(angle) * radius, height, Math.sin(angle) * radius);
    const size = 8.5 + Math.random() * 2;
    sprite.scale.set(size, size, 1);
    sprite.center.set(0.5, 0.5);
    flowerRing.add(sprite);
    sprites.push(sprite);
  }

  textures.forEach((texture, poolIdx) => {
    texture.colorSpace = THREE.SRGBColorSpace;
    const flowerMaterial = new THREE.SpriteMaterial({
      map: texture,
      color: 0xffffff,
      transparent: true,
      opacity: 1,
      depthWrite: false
    });
    sprites.forEach((sprite) => {
      if (sprite.userData.imgIdx === poolIdx) {
        sprite.material = flowerMaterial;
        sprite.material.needsUpdate = true;
      }
    });
  });

  let heartPointsMesh = null;
  const heartVertices = [];
  const heartPhases = [];
  const heartPath = document.getElementById('heartPath');
  if (heartPath) {
    const heartLength = heartPath.getTotalLength();
    for (let t = 0; t < heartLength; t += 0.1) {
      const p = heartPath.getPointAtLength(t);
      const v = new THREE.Vector3(p.x - 300, -p.y + 276, 0);
      v.x += (Math.random() - 0.5) * 30;
      v.y += (Math.random() - 0.5) * 30;
      v.z += (Math.random() - 0.5) * 70;
      heartVertices.push(v);
      heartPhases.push(Math.random() * Math.PI * 2);
    }
    const heartGeom = new THREE.BufferGeometry().setFromPoints(heartVertices);
    const posAttr = new Float32Array(heartVertices.length * 3);
    for (let i = 0; i < heartVertices.length; i++) {
      posAttr[i * 3] = heartVertices[i].x;
      posAttr[i * 3 + 1] = heartVertices[i].y;
      posAttr[i * 3 + 2] = heartVertices[i].z;
    }
    heartGeom.setAttribute('position', new THREE.BufferAttribute(posAttr, 3));
    const heartMat = new THREE.PointsMaterial({ color: 0xee5282, size: 0.08, blending: THREE.AdditiveBlending, transparent: true });
    heartPointsMesh = new THREE.Points(heartGeom, heartMat);
    heartPointsMesh.position.set(0, 42, 0);
    scene.add(heartPointsMesh);
  }

  const fontLoader = new FontLoader();
  fontLoader.load('https://unpkg.com/three@0.152.2/examples/fonts/helvetiker_regular.typeface.json', font => {
    const text1 = 'HAPPY 20/10 HAPPY 20/10 HAPPY 20/10 HAPPY 20/10 HAPPY 20/10 HAPPY 20/10 HAPPY 20/10 HAPPY 20/10 HAPPY 20/10  ';
    const text2 = text1;
    const text3 = text1;
    const radius1 = 48, radius2 = 42;
    const speed = 0.006, speed3 = 0.005;
    const textRing1 = new THREE.Group(), textRing2 = new THREE.Group(), textRing3 = new THREE.Group();
    scene.add(textRing1, textRing2, textRing3);

    for (let i=0;i<text1.length;i++){
      const g = new TextGeometry(text1[i], { font, size:1.8, height:0.3, curveSegments:12, bevelEnabled:false });
      const m = new THREE.MeshBasicMaterial({ color:0xffffff });
      const letter = new THREE.Mesh(g,m);
      const angle = (i/text1.length)*Math.PI*2;
      letter.position.x = radius1 * Math.cos(angle);
      letter.position.z = radius1 * Math.sin(angle);
      letter.rotation.y = -angle - Math.PI/2;
      textRing1.add(letter);
    }

    for (let i=0;i<text2.length;i++){
      const g = new TextGeometry(text2[i], { font, size:1.8, height:0.3, curveSegments:12, bevelEnabled:false });
      const m = new THREE.MeshBasicMaterial({ color:0xffffff });
      const letter = new THREE.Mesh(g,m);
      const angle = (i/text2.length)*Math.PI*2;
      letter.position.x = radius2 * Math.cos(angle);
      letter.position.z = radius2 * Math.sin(angle);
      letter.rotation.y = -angle - Math.PI/2;
      textRing2.add(letter);
    }

    const letters3 = [];
    const newRadius3 = Math.sqrt(780*780 + 680*680);
    const startAngle = Math.atan2(680, 780);
    const textMaterial = new THREE.ShaderMaterial({
      uniforms: { fadeStartY: { value:680.0 }, fadeRange: { value:100.0 } },
      vertexShader: `varying float vY; void main(){ vY=position.y; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
      fragmentShader: `uniform float fadeStartY; uniform float fadeRange; varying float vY; void main(){ float alpha=1.0; if(vY<fadeStartY) alpha=smoothstep(fadeStartY-fadeRange, fadeStartY, vY); gl_FragColor = vec4(1.0,1.0,1.0,alpha); }`,
      transparent:true
    });
    for (let i=0;i<text3.length;i++){
      const g = new TextGeometry(text3[i], { font, size:15, height:0.5, curveSegments:12, bevelEnabled:false });
      const letter = new THREE.Mesh(g, textMaterial.clone());
      const angle = startAngle + (i/text3.length)*Math.PI*2;
      letter.position.x = newRadius3 * Math.cos(angle);
      letter.position.y = newRadius3 * Math.sin(angle);
      letter.rotation.z = angle + Math.PI/2;
      letter.userData = { initialAngle: angle, index: i };
      textRing3.add(letter);
      letters3.push(letter);
    }

    textRing1.rotation.z = Math.PI/4;
    textRing2.rotation.z = -Math.PI/4;
    textRing3.rotation.z = Math.PI/4;

    startAnimationLoop({ letters3, textRing1, textRing2, textRing3, speed, speed3 });
  });

  setTimeout(()=>{ if (!window._animationStarted) startAnimationLoop({}); }, 1500);

  let lastFrameTime = 0;
  function startAnimationLoop(ctx){
    if (window._animationStarted) return;
    window._animationStarted = true;
    const letters3 = (ctx && ctx.letters3) || [];
    const textRing1 = (ctx && ctx.textRing1) || { rotation: { y: 0 } };
    const textRing2 = (ctx && ctx.textRing2) || { rotation: { y: 0 } };
    const textRing3 = (ctx && ctx.textRing3) || { rotation: { y: 0 } };
    const speed = (ctx && ctx.speed) || 0.006;
    const speed3 = (ctx && ctx.speed3) || 0.005;

    function animate(time){
      requestAnimationFrame(animate);
      if (time - lastFrameTime < 16) return;
      lastFrameTime = time;

      const t = time * 0.001;

      particles.rotation.y += 0.0008;
      sphere.rotation.y += 0.0008;
      sphere.rotation.x += 0.0008;
      sphereMaterial.uniforms.uTime.value = time * 0.0008;
      atmosphereMaterial.uniforms.uTime.value = time * 0.0008;

      textRing1.rotation.y += speed;
      textRing2.rotation.y -= speed;

      for (let i=0;i<letters3.length;i++){
        const letter = letters3[i];
        const angle = letter.userData.initialAngle + t * 0.001 * speed3;
        letter.position.x = Math.cos(angle) * Math.sqrt(780*780 + 680*680);
        letter.position.y = Math.sin(angle) * Math.sqrt(780*780 + 680*680);
        letter.rotation.z = angle + Math.PI/2;
      }

      flowerRing.rotation.y += 0.0008;
      particleDisk.rotation.y += 0.0008;
      innerParticleDisk.rotation.y += 0.0008;
      outermostParticleDisk.rotation.y += 0.0008;

      if (heartPointsMesh) {
        const posAttr = heartPointsMesh.geometry.attributes.position;
        for (let i=0;i<heartVertices.length;i++){
          const base = heartVertices[i];
          const phase = heartPhases[i];
          posAttr.array[i*3]   = base.x + Math.sin(t*2 + phase) * 2.0;
          posAttr.array[i*3+1] = base.y + Math.cos(t*2 + phase) * 1.5;
          posAttr.array[i*3+2] = base.z + Math.sin(t*1.5 + phase) * 2.0;
        }
        posAttr.needsUpdate = true;
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate(0);
  }

  let isAnimating = false;
  function triggerCameraAnimation(){
    if (isAnimating) return;
    isAnimating = true; controls.enabled = false;
    const startTarget = { x: controls.target.x, y: controls.target.y, z: controls.target.z };
    const tl = gsap.timeline({
      onUpdate: ()=>{ controls.update(); },
      onComplete: ()=>{ isAnimating=false; controls.enabled=true; }
    });
    tl.to(camera.position, { y:15, z:150, duration:7, ease:"power2.inOut" })
      .to(camera.position, { y:15, z:530, duration:45, ease:"power2.inOut" });
    gsap.to(startTarget, { y:0, duration:7, ease:"power2.inOut", onUpdate: ()=>{ controls.target.set(startTarget.x,startTarget.y,startTarget.z); controls.update(); }});
  }

  window.addEventListener('resize', ()=> {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  window.addEventListener('beforeunload', ()=> {
    try {
      renderer.dispose();
      scene.traverse(obj => {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (obj.material.map) obj.material.map.dispose();
          obj.material.dispose();
        }
      });
    } catch(e){}
  });

  </script>
</body>
</html>